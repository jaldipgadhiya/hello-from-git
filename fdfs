{"longURL":"https://balicuat.bajajallianz.com/rblPdfGen/service/gen/nafBI?userId=U1&origin=AXISPsForm&appNo=6140376399"}
{
  "longURL": "https://balicuat.bajajallianz.com/rblPdfGen/service/gen/nafBI?userId=U1\u0026origin=AXISPsForm\u0026appNo=6140376399"
}
DECLARE
   l_url VARCHAR2(4000);
   l_escaped_url VARCHAR2(4000);
   l_json_input CLOB;
BEGIN
   l_url := 'https://balicuat.bajajallianz.com/rblPdfGen/service/gen/nafBI?userId=U1&origin=AXISPsForm&appNo=6140376399';
   
   l_escaped_url := UTL_URL.ESCAPE(l_url);

   l_json_input := '{"longURL": "' || l_escaped_url || '"}';

   -- Call your API with l_json_input
   -- For example, using UTL_HTTP to make the API call
   -- UTL_HTTP.request('https://your-api-url', 'POST', l_json_input);
END;
/

1. write query reports the salary for each employee, along with the average salary of the employees within the department.
with q1 as
(select deptno,sal,avg(sal) over(partition by deptno) from emp)
select * from q1;

2. sum of salary dept wise and job wise
with q1 as
(select deptno,sum(sal) over(partition by deptno) dept_wise,sum(sal) over(partition by job) job_wise from emp)
select * from q1;

3. define rank and dense rank deptwise
with q1 as
(select deptno,sal,rank() over(partition by deptno order by sal desc) dept_wise_rank,dense_rank() over(partition by deptno order by sal desc) dept_wise_denserank from emp)
select * from q1;

4. select * from hr.employees,
I want the employee details who joined 3rd in each department 

with q1 as
(select empno,row_number() over(partition by deptno order by hiredate) pos from emp)
select q1.pos,e.* from q1,emp e
where q1.empno = e.empno
and q1.pos = 3;


5. Test1 col1, Test2 col1
1		0
1		1
0		0
1		1
1		0
null		null
		null

output of inner,right,left,full outer join

create table tab1(a number);
create table tab2(a number);
insert into tab1 values(1); 
insert into tab1 values(1);
insert into tab1 values(0);
insert into tab1 values(1);
insert into tab1 values(1);
insert into tab1 values(null);
insert into tab2 values(0);
insert into tab2 values(1);
insert into tab2 values(0);
insert into tab2 values(1);
insert into tab2 values(0);
insert into tab2 values(null);
insert into tab2 values(null);

Partition Pruning

Oracle partition pruning is a divided and conquer approach.Partition pruning is an essential performance feature. In partition pruning, the optimizer analyzes FROM and WHERE clauses in SQL statements to eliminate unneeded partitions when building the partition access list. This functionality enables Oracle Database to perform operations only on those partitions that are relevant to the SQL statement.
Partition pruning dramatically reduces the amount of data retrieved from disk and shortens processing time, thus improving query performance and optimizing resource utilization.
Depending upon the actual SQL statement, Oracle Database may use static or dynamic pruning. 

Static pruning occurs at compile-time, with the information about the partitions accessed beforehand. 
Dynamic pruning occurs at run-time, meaning that the exact partitions to be accessed by a statement are not known beforehand. 

A sample scenario for static pruning is a SQL statement containing a WHERE condition with a constant literal on the partition key column. 
An example of dynamic pruning is the use of operators or functions in the WHERE condition.
